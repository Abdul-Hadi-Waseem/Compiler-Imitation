E -> PROGRAM
PROGRAM -> FUNCTIONS MAIN
PROGRAM -> FUNCTIONS
PROGRAM -> MAIN
DATA_TYPE -> INT
DATA_TYPE -> FLOAT
DATA_TYPE -> STRING
DATA_TYPE -> BOOLEAN
DATA_TYPE -> ARRAY
INT -> int
FLOAT -> float
STRING -> string
BOOLEAN -> bool
OPERATOR -> +
OPERATOR -> -
OPERATOR -> *
OPERATOR -> %
OPERATOR -> and
OPERATOR -> or
OPERATOR -> not
OPERATOR -> ?
OPERATOR -> :
OPERATOR -> ^
OPERATOR -> ~
OPERATOR -> =
OPERATOR -> ==
OPERATOR -> !=
OPERATOR -> >
OPERATOR -> >=
OPERATOR -> <
OPERATOR -> <=
FUNCTIONS -> FUNCTIONS FUNCTION
FUNCTIONS -> FUNCTION
FUNCTION -> def ID ( PARAMETERS ) : DATA_TYPE { NL STATEMENTS }
FUNCTION -> def ID ( ) : DATA_TYPE { NL STATEMENTS }
MAIN -> def main ( ) : void { NL STATEMENTS }
PARAMETERS -> DATA_TYPE ID
PARAMETERS -> DATA_TYPE ID , PARAMETERS
STATEMENTS -> STATEMENT STATEMENTS
STATEMENTS -> STATEMENT
STATEMENT -> DECLARATION
STATEMENT -> ASSIGNMENT
STATEMENT -> DECLARATION_ASSIGNMENT
STATEMENT -> EXPRESSION
STATEMENT -> CONDITIONAL
STATEMENT -> LOOP
STATEMENT -> RETURN
STATEMENT -> BREAK
STATEMENT -> CONTINUE
DECLARATION -> DATA_TYPE ID_LIST NL
ID_LIST -> ID , ID_LIST
ID_LIST -> ID
ASSIGNMENT -> ID = EXPRESSION NL
ASSIGNMENT -> ID = EXPRESSION , ASSIGNMENT
DECLARATION_ASSIGNMENT -> DATA_TYPE ASSIGNMENT
EXPRESSION -> ( EXPRESSION OPERATOR EXPRESSION )
EXPRESSION -> LITERAL
EXPRESSION -> ID
EXPRESSION -> FUNCTION_CALL
EXPRESSION_LIST -> EXPRESSION , EXPRESSION_LIST
EXPRESSION_LIST -> EXPRESSION
LITERAL -> STRING_LITERAL
LITERAL -> INTEGER_LITERAL
LITERAL -> FLOAT_LITERAL
LITERAL -> CHARACTER_LITERAL
LITERAL -> BOOLEAN_LITERAL
CONDITIONAL -> if ( EXPRESSION ) { NL STATEMENTS }
CONDITIONAL -> if ( EXPRESSION ) { NL STATEMENTS } else { NL STATEMENTS }
CONDITIONAL -> if ( EXPRESSION ) { NL STATEMENTS } ELIF
CONDITIONAL -> if ( EXPRESSION ) { NL STATEMENTS } ELIF else { NL STATEMENTS }
ELIF -> elif ( EXPRESSION ) { NL STATEMENTS } ELIF
ELIF -> elif ( EXPRESSION ) { NL STATEMENTS }
LOOP -> while ( EXPRESSION ) { NL  STATEMENTS }
LOOP -> for (ASSIGNMENT , EXPRESSION , EXPRESSION) { NL STATEMENTS }
RETURN -> return EXPRESSION NL
RETURN -> return NL
BREAK -> break NL
CONTINUE -> continue NL
FUNCTION_CALL -> ID ( EXPRESSION_LIST ) NL
FUNCTION_CALL -> ID ( ) NL